[{"title":"View Transitions Api","tags":["css","animation"],"categories":"前端小记","author":"墨眉","excerpt":"\n### 概述\n\n> [View Transitions Api](https://developer.mozilla.org/zh-CN/docs/Web/API/View_Transitions_API)\n> View Transitions API 提供了一种机制，可以在更新 DOM 内容的同时，轻松地创建不同 DOM 状态之间的动画过渡。同时还可以在单个步骤中更新 DOM 内容。\n> ps:不同dom之间的视图过渡\n\n### 常见的过渡/动画创建方式\n\n1. [transition/keyframes](https://developer.mozilla.org/zh-CN/docs/Web/CSS/transition) （ 补间动画，帧动画 ）\n2. [requestAnimationFrame](https://developer.mozilla.org/zh-CN/docs/Web/API/window/requestAnimationFrame) （ js 动画，每帧回调 ）\n3. [Web Animation Api](https://developer.mozilla.org/zh-CN/docs/Web/API/Web_Animations_API)（ 和css动画一样在合成层渲染，js更好的干预和控制 ）\n4. [View Transitions Api](https://developer.mozilla.org/zh-CN/docs/Web/API/View_Transitions_API) （ 两个视图或者dom之间的过渡 ）\n","link":"/posts/ViewTransition"},{"title":"Web Animations API 写一个动画指令","tags":["demo","vue","Web Animations API"],"categories":"前端小记","author":"墨眉","excerpt":"\r\n### [Web Animations API](https://developer.mozilla.org/zh-CN/docs/Web/API/Web_Animations_API/Using_the_Web_Animations_API)\r\n\r\n> 通过 Web 动画 API，我们可以将交互式动画从样式表移动到  JavaScript，将表现与行为分开。我们不再需要依赖 DOM 重的技术，如将 CSS 属性和范围类写入元素来控制播放方向。\r\n\r\n<span class=\"text-red-600\"> 和 Css 动画有什么区别？</span>\r\n\r\nCSS 动画和 Web Animations API 都可以用于创建动画，但它们之间有一些区别。CSS 动画是通过 CSS 属性来控制的，而 Web Animations API 是通过 JavaScript 来控制的。此外，Web Animations API 还提供了更多的功能，例如更好的时间控制和更好的事件处理。\r\n\r\n<span class=\"text-red-600\" > 性能方面如何？</span>\r\n\r\nWeb Animations API 提供了更多的控制和更好的性能，因为它可以调用不同于浏览器主线程的其他线程去渲染该动画（这些线程包括合成线程、动画线程和渲染线程。合成线程负责将页面的各个部分组合成一张图像，动画线程负责计算动画的状态，而渲染线程负责将图像绘制到屏幕上）\r\n\r\n所以一些复杂的动画可选择 Web Animations API 。\r\n\r\n> 记录一篇掘金文章 [什么是Web Animations API？](https://juejin.cn/post/7065093728737689614)\r\n","link":"/posts/WebAnimationDirective"},{"title":"createVNode/render创建notify组件","tags":["vue3","createVNode/render"],"categories":"前端小记","author":"墨眉","excerpt":"### 概述\n阅读element notify组件（~~摸鱼真爽~~）。\n> createVNode/render 相比于模板语法有更高的自由度，在需要js的完全编程能力时非常有用。\n\n\n### 编程式触发创建\n\n1. 定义组件模板（component）\n2. 定义props参数和触发事件\n3. 缓存vnode，后续通过vnode缓存计算定位高度\n","link":"/posts/createVNode_render%E5%88%9B%E5%BB%BAnotify%E7%BB%84%E4%BB%B6"},{"title":"js实现瀑布流","tags":["demo"],"categories":"前端小记","author":"墨眉","excerpt":"\r\n### 为什么使用 Js 实现瀑布流\r\n\r\n>  瀑布流的本质：获取获取最小高度的列，向其中添加图片，使列之间保持一个尽可能接近的高度。\r\n\r\n### 能否使用 Css 实现？flex ? grid ?\r\n\r\n不能，css 并不能计算出列的最小高度，所以必须使用 js 实时计算。\r\n\r\n### Steps\r\n\r\n1. 在 window resize的时候计算列的数量\r\n2. 缓存一个 < 列 ，高度 > 的对象，每次塞图片，更新对象的列高度\r\n3. 从缓存 map 中找到最小高的列，向其中塞入图片\r\n4. 在 窗口 resize 的时候， 对已有元素重排\r\n5. 触底加载更多图片\r\n\r\n","link":"/posts/js%E5%AE%9E%E7%8E%B0%E7%80%91%E5%B8%83%E6%B5%81"},{"title":"monorepo子进程打包packages","tags":["vue","monorepo","rollup"],"categories":"前端小记","author":"墨眉","excerpt":"\r\n### 如何并发build多个package\r\n\r\n通常情况下一个项目下有一个 rollup.config.js 文件来做打包配置。在多包情况下也可以在根目录下配置一个 rollup.config.js文件，\r\n\r\n在配置文件中动态的获取入口和输出目录。\r\n\r\n<span class=\"text-red-600\">如何动态获取？</span>\r\n\r\n我们可以在构建的时候控制命令参数传给进程，使用 node 的进程 ``` process.env ``` 获取。\r\n\r\n### 配置packages路径\r\n\r\n```js\r\nimport path from 'node:path'\r\nimport { fileURLToPath } from 'url'\r\n\r\n\r\nexport const projRoot = path.resolve(fileURLToPath(import.meta.url), '../','../')\r\nexport const pkgRoot = path.resolve(projRoot, 'packages')\r\n\r\nexport const directivesRoot = path.resolve(pkgRoot, 'directives')\r\nexport const componentsRoot = path.resolve(pkgRoot, 'components')\r\nexport const hooksRoot = path.resolve(pkgRoot, 'hooks')\r\nexport const stylesRoot = path.resolve(pkgRoot, 'styles')\r\nexport const utilsRoot = path.resolve(pkgRoot, 'utils')\r\n```\r\n\r\n> 由于是 esmodule ,是无法识别 __dirname 的，可以使用 fileURLToPath方法转换模块路径为相对路径\r\n\r\n","link":"/posts/monorepo%E5%AD%90%E8%BF%9B%E7%A8%8B%E6%89%93%E5%8C%85packages"},{"title":"TinyMCE薄封装","tags":["TinyMCE"],"categories":"前端小记","author":"墨眉","excerpt":"<a-box style=\"display:flex;width:100%\">\n<img style=\"width:50%;objectFit:cover;\" src='/contents/tinymce/light.png' />\n<img style=\"width:50%;objectFit:cover;\" src='/contents/tinymce/dark.png' />\n</a-box>\n\n\n\n### TinyMCE三种模式\n\n1. 经典模式：基于iframe的沙箱模式，总是显示操作栏且拥有大量的操作按钮；样式上并非所见即所得（iframe的原因），更适合展示性要求不高的场景，比如表单项。\n2. 内联模式：基于普通块元素为容器（div），实现阅读视图和编辑视图的合并，所见及所得，不总是显示菜单栏；更适合展示性较强的场景，比如文章内容。\n3. 无干扰模式，似乎只是比内联模式少了菜单栏，使用上下文菜单，操作更加的轻巧（maybe）。\n\n### install & setup\n\n> npm i tinymce\n\n","link":"/posts/tinyMCE"},{"title":"vue组件库搭建","tags":["demo","组件库","monorepo"],"categories":"前端小记","author":"墨眉","excerpt":"\r\n\r\n\r\n\r\n\r\n### 环境搭建\r\n\r\n1. 安装 pnpm  ，使用 pnpm 包管理器管理项目\r\n2. 使用 vite 作为开发服务器和打包工具\r\n3. 安装 sass 预处理器，安装 vue \r\n### monorepo\r\n\r\n1. 新建一个 pacakages 文件夹，里面存放多个项目仓库\r\n\r\n2. 新建一个 pnpm-work-space.yaml 文件,指定 [workspace](https://pnpm.io/zh/workspaces), pnpm 如果安装本地包在工作空间中存在，那么会直接链接包。不存在声明范围内的包， pnpm 会拒绝解析安装。\r\n\r\n   packages下面的在 package.json 中指定 name 包名，通过 -w 安装，例如： pnpm i @momei-ui/components -w \r\n\r\n   ```yaml\r\n   packages:\r\n     - packages/*\r\n     - play\r\n   ```\r\n","link":"/posts/vue%E7%BB%84%E4%BB%B6%E5%BA%93%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA"},{"title":"电子签名（signature_pad）","tags":["demos","vue3"],"categories":"前端小记","author":"墨眉","excerpt":"\n<a-box>\n<img src='/contents/电子签名/sign.png' />\n</a-box>\n\n### [signature_pad](https://github.com/szimek/signature_pad)\n```typescript\nnpm i signature_pad\n```\n","link":"/posts/%E7%94%B5%E5%AD%90%E7%AD%BE%E5%90%8D"},{"title":"vue-router history部署后刷新404","tags":["vue-router","nginx"],"categories":"前端小记","author":"墨眉","excerpt":"\r\n### hash模式\r\n\r\n[hash](https://developer.mozilla.org/zh-CN/docs/Web/API/Location/hash)模式是在域名和 path 之间使用```#```进行分隔，```#```及其后面的 url 片段标识符就是 hash 字符串。\r\n\r\n> 例如： 127.0.0.1/#/login  , hash  就是  #/login  \r\n\r\nhash 的特点是页面刷新和改变 hash ，hash 不会被带入网络请求。\r\n\r\n> 例如：当我们分别请求  [https://juejin.cn/](https://juejin.cn/) 和 [https://juejin.cn/#aaa](https://juejin.cn/#aaa) ,会发现 network 中始终只有  https://juejin.cn/ 的 网络请求。再次说明了 hash 不会影响网络请求结果。\r\n\r\n<a-box>\r\n<img src=\"/contents/postAssets/rt.png\" />\r\n</a-box>\r\n\r\n\r\n所以，实际上我们的路由每次刷新都是请求的相同的 url ，返回的始终是一个页面，由于是 SPA 的特性，实际上已经加载完所有需要的页面资源了，页面的切换不过是通过监听 hash 的改变，执行 js 脚本来更换视图模块。\r\n\r\n","link":"/posts/%E8%B7%AF%E7%94%B1history%E9%83%A8%E7%BD%B2%E5%90%8E%E5%88%B7%E6%96%B0404"},{"title":"钉钉官网动效简易实现","tags":["demos","animation"],"categories":"前端小记","author":"墨眉","excerpt":"### 概述\r\n\r\n>渡一短视频--钉钉官网动效demo\r\n1. 动画状态函数\r\n2. sticky布局\r\n\r\n","link":"/posts/%E9%92%89%E9%92%89%E5%AE%98%E7%BD%91%E5%8A%A8%E6%95%88%E7%AE%80%E6%98%93%E5%AE%9E%E7%8E%B0"}]
